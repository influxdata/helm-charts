# Production Configuration
# - Full resource allocation
# - AWS S3 with multiple availability zones
# - High availability with multiple replicas
# - Pod Disruption Budgets for zero-downtime maintenance
# - Full monitoring and network policies
# - TLS enabled

objectStorage:
  type: s3
  bucket: "influxdb3"
  s3:
    region: "us-east-1"
    accessKeyId: "PROD_ACCESS_KEY"
    secretAccessKey: "PROD_SECRET_KEY"

license:
  type: "commercial"
  email: "production@example.com"

ingester:
  replicas: 3
  resources:
    requests:
      cpu: "4000m"
      memory: "8Gi"
    limits:
      cpu: "8000m"
      memory: "16Gi"
  numIOThreads: 12
  datafusion:
    numThreads: 20
  persistence:
    storageClass: "fast-ssd"
    size: "100Gi"
  # Pod anti-affinity to guarantee pods spread across nodes
  # Note: Using "required" ensures pods never colocate on the same node
  # This requires having at least as many nodes as replicas
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: ingester
          topologyKey: kubernetes.io/hostname
  # Enable Pod Disruption Budget for HA
  podDisruptionBudget:
    enabled: true
    maxUnavailable: 1              # Allow 1 of 3 pods to be disrupted

querier:
  replicas: 3
  resources:
    requests:
      cpu: "4000m"
      memory: "8Gi"
    limits:
      cpu: "8000m"
      memory: "16Gi"
  datafusion:
    numThreads: 28
  # Pod anti-affinity to guarantee pods spread across nodes
  # Note: Using "required" ensures pods never colocate on the same node
  # This requires having at least as many nodes as replicas
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: querier
          topologyKey: kubernetes.io/hostname
  # Enable Pod Disruption Budget for HA
  podDisruptionBudget:
    enabled: true
    maxUnavailable: 1              # Allow 1 of 3 pods to be disrupted

compactor:
  resources:
    requests:
      cpu: "4000m"
      memory: "8Gi"
    limits:
      cpu: "8000m"
      memory: "16Gi"
  datafusion:
    numThreads: 30
  compaction:
    checkInterval: "5s"

processingEngine:
  enabled: true
  replicas: 2
  # Pod anti-affinity to guarantee pods spread across nodes
  # Note: Using "required" ensures pods never colocate on the same node
  # This requires having at least as many nodes as replicas
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: processor
          topologyKey: kubernetes.io/hostname
  # Enable Pod Disruption Budget for HA
  podDisruptionBudget:
    enabled: true
    maxUnavailable: 1              # Allow 1 of 2 pods to be disrupted

ingress:
  host: "influxdb-api.example.com"
  tls:
    - secretName: influxdb-api-tls
      hosts:
        - influxdb-api.example.com
  write:
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/rate-limit: "1000"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
  query:
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"

# Enable network policies
networkPolicy:
  enabled: true
  ingress:
    fromIngressController: true
    fromComponents: true
    fromPrometheus: true  # Allow Prometheus to scrape metrics
  egress:
    toDns: true
    toObjectStorage: true

# Enable monitoring
serviceMonitor:
  enabled: true
  interval: 30s
  scrapeTimeout: 10s
  additionalLabels:
    prometheus: kube-prometheus
