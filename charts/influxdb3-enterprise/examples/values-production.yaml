# Production Configuration
# - Full resource allocation
# - AWS S3 with multiple availability zones
# - High availability with multiple replicas
# - Pod Disruption Budgets for zero-downtime maintenance
# - Health probes enabled
# - Full monitoring and network policies
# - TLS enabled

objectStorage:
  type: s3
  bucket: "influxdb3"
  s3:
    enabled: true
    region: "us-east-1"
    accessKeyId: "PROD_ACCESS_KEY"
    secretAccessKey: "PROD_SECRET_KEY"

license:
  type: "commercial"
  email: "production@example.com"

# Enable health probes (no token required - /health endpoint auth is disabled by default)
probes:
  enabled: true

ingester:
  replicas: 3
  resources:
    requests:
      cpu: "4000m"
      memory: "8Gi"
    limits:
      cpu: "8000m"
      memory: "16Gi"
  threads:
    io: 12
    datafusion: 20
  persistence:
    storageClass: "fast-ssd"
    size: "100Gi"
  # Pod anti-affinity to guarantee pods spread across nodes
  # Note: Using "required" ensures pods never colocate on the same node
  # This requires having at least as many nodes as replicas
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: ingester
          topologyKey: kubernetes.io/hostname
  # Enable Pod Disruption Budget for HA
  podDisruptionBudget:
    enabled: true
    minAvailable: 2              # Keep at least 2 of 3 pods available

querier:
  replicas: 3
  resources:
    requests:
      cpu: "4000m"
      memory: "8Gi"
    limits:
      cpu: "8000m"
      memory: "16Gi"
  threads:
    datafusion: 28
  # Pod anti-affinity to guarantee pods spread across nodes
  # Note: Using "required" ensures pods never colocate on the same node
  # This requires having at least as many nodes as replicas
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: querier
          topologyKey: kubernetes.io/hostname
  # Enable Pod Disruption Budget for HA
  podDisruptionBudget:
    enabled: true
    minAvailable: 2              # Keep at least 2 of 3 pods available

compactor:
  resources:
    requests:
      cpu: "4000m"
      memory: "8Gi"
    limits:
      cpu: "8000m"
      memory: "16Gi"
  threads:
    datafusion: 30
  compaction:
    checkInterval: "5s"

processingEngine:
  enabled: true
  replicas: 2
  # Pod anti-affinity to guarantee pods spread across nodes
  # Note: Using "required" ensures pods never colocate on the same node
  # This requires having at least as many nodes as replicas
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app.kubernetes.io/component: processor
          topologyKey: kubernetes.io/hostname
  # Enable Pod Disruption Budget for HA
  podDisruptionBudget:
    enabled: true
    minAvailable: 1              # Keep at least 1 of 2 pods available

ingress:
  write:
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/rate-limit: "1000"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
    hosts:
      - host: "influxdb-api.example.com"
    tls:
      - secretName: influxdb-api-tls
        hosts:
          - influxdb-api.example.com

  query:
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
    hosts:
      - host: "influxdb-api.example.com"
    tls:
      - secretName: influxdb-api-tls
        hosts:
          - influxdb-api.example.com

# Enable network policies
networkPolicy:
  enabled: true
  ingress:
    fromIngressController: true
    fromComponents: true
  egress:
    toDns: true
    toObjectStorage: true
    toKubeApi: true

# Enable monitoring
serviceMonitor:
  enabled: true
  interval: 30s
  scrapeTimeout: 10s
  additionalLabels:
    prometheus: kube-prometheus

# Advanced configuration
cache:
  parquetMemCacheSize: "20%"
  lastValueCacheDisableFromHistory: false
  distinctValueCacheDisableFromHistory: false

dataLifecycle:
  retentionCheckInterval: "15m"
  deleteGracePeriod: "24h"

logging:
  filter: "info"
  queryLogSize: 10000

telemetry:
  disableUpload: false
